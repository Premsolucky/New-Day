import { createServer as createServer$1 } from 'http';
import { createServer } from 'https';
import pino from 'pino';
import { getNodeRequest, sendNodeResponse } from '@ardatan/graphql-helix';
import { BaseGraphQLServer } from '@graphql-yoga/core';
export { GraphQLBlob } from '@graphql-yoga/core';
import { EnvelopError } from '@envelop/core';
export { EnvelopError as GraphQLServerError, enableIf, envelop, useEnvelop, useExtendContext, usePayloadFormatter, useTiming } from '@envelop/core';
import LightMyRequest from 'light-my-request';
import { print } from 'graphql';

/**
 * Create a simple yet powerful GraphQL server ready for production workloads.
 * Spec compliant server that supports bleeding edge GraphQL features without any vendor lock-ins.
 *
 * Comes baked in with:
 *
 * - Envelop - Plugin system for GraphQL
 * - GraphQL Helix - Extensible and Framework agnostic GraphQL server
 * - GraphiQL - GraphQL IDE for your browser
 * - Pino - Super fast, low overhead Node.js logger
 *
 * Example:
 * ```ts
 *  import { schema } from './schema'
 *   // Provide a GraphQL schema
 *  const server = new GraphQLServer({ schema })
 *  // Start the server. Defaults to http://localhost:4000/graphql
 *  server.start()
 * ```
 */
class GraphQLServer extends BaseGraphQLServer {
    constructor(options) {
        var _a, _b;
        super({
            ...options,
            // This should make default to dev mode base on environment variable
            isDev: (_a = options.isDev) !== null && _a !== void 0 ? _a : process.env.NODE_ENV !== 'production',
        });
        this.port = options.port || parseInt(process.env.PORT || '4000');
        this.endpoint = options.endpoint || '/graphql';
        this.hostname = options.hostname || '0.0.0.0';
        // Pretty printing only in dev
        const prettyPrintOptions = this.isDev
            ? {
                transport: {
                    target: 'pino-pretty',
                    options: {
                        translateTime: true,
                        colorize: true,
                    },
                },
            }
            : {};
        this.logger = pino({
            ...prettyPrintOptions,
            level: this.isDev ? 'debug' : 'info',
            enabled: (_b = options.enableLogging) !== null && _b !== void 0 ? _b : true,
        });
        this.logger.debug('Setting up server.');
        if (options.https) {
            this._server =
                typeof options.https === 'object'
                    ? createServer(options.https, this.requestListener.bind(this))
                    : createServer(this.requestListener.bind(this));
        }
        else {
            this._server = createServer$1(this.requestListener.bind(this));
        }
    }
    async handleIncomingMessage(...args) {
        this.logger.debug('Node Request received', ...args);
        const request = await getNodeRequest(...args);
        const response = await this.handleRequest(request);
        return response;
    }
    async requestListener(req, res) {
        const response = await this.handleIncomingMessage(req);
        await sendNodeResponse(response, res);
    }
    get server() {
        return this._server;
    }
    start(callback = () => {
        this.logger.info(`GraphQL server running at http://${this.hostname}:${this.port}${this.endpoint}.`);
    }) {
        return new Promise((resolve) => {
            this._server.listen(this.port, this.hostname, () => {
                callback();
                resolve();
            });
        });
    }
    stop(callback = (err) => {
        if (err) {
            this.logger.error('Something went wrong :( trying to shutdown the server.', err);
        }
        else {
            this.logger.info('Shutting down GraphQL server.');
        }
    }) {
        return new Promise((resolve, reject) => {
            this._server.close((err) => {
                callback(err);
                if (err != null) {
                    reject(new EnvelopError(err.message));
                }
                else {
                    resolve();
                }
            });
        });
    }
    /**
     * Testing utility to mock http request for GraphQL endpoint
     *
     *
     * Example - Test a simple query
     * ```ts
     * const response = await yoga.inject({
     *  document: "query { ping }",
     * })
     * expect(response.statusCode).toBe(200)
     * expect(response.data.ping).toBe('pong')
     * ```
     **/
    async inject({ document, variables, operationName, headers, }) {
        const response = await LightMyRequest.inject(this.requestListener.bind(this), {
            method: 'POST',
            url: this.endpoint,
            headers,
            payload: JSON.stringify({
                query: typeof document === 'string' ? document : print(document),
                variables,
                operationName,
            }),
        });
        return {
            response,
            get executionResult() {
                return JSON.parse(response.payload);
            },
        };
    }
}

export { GraphQLServer };
