"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getErrorResponse = exports.getPushResponse = exports.getMultipartResponse = exports.getRegularResponse = exports.DEFAULT_TRANSFORM_RESULT_FN = void 0;
const calculate_byte_length_1 = require("./calculate-byte-length");
const cross_undici_fetch_1 = require("cross-undici-fetch");
const DEFAULT_TRANSFORM_RESULT_FN = (result) => result;
exports.DEFAULT_TRANSFORM_RESULT_FN = DEFAULT_TRANSFORM_RESULT_FN;
function getRegularResponse(executionResult, transformResult = exports.DEFAULT_TRANSFORM_RESULT_FN) {
    const transformedResult = transformResult(executionResult);
    const responseBody = JSON.stringify(transformedResult);
    const contentLength = (0, calculate_byte_length_1.calculateByteLength)(responseBody);
    const headersInit = {
        "Content-Type": 'application/json',
        "Content-Length": contentLength.toString()
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    return new cross_undici_fetch_1.Response(responseBody, responseInit);
}
exports.getRegularResponse = getRegularResponse;
function getMultipartResponse(asyncExecutionResult, transformResult = exports.DEFAULT_TRANSFORM_RESULT_FN) {
    const headersInit = {
        Connection: "keep-alive",
        "Content-Type": 'multipart/mixed; boundary="-"',
        "Transfer-Encoding": "chunked",
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    const readableStream = new cross_undici_fetch_1.ReadableStream({
        async start(controller) {
            try {
                controller.enqueue(`---`);
                const iterator = asyncExecutionResult[Symbol.asyncIterator]();
                while (true) {
                    const { done, value } = await iterator.next();
                    if (done) {
                        controller.enqueue("\r\n-----\r\n");
                        controller.close();
                        break;
                    }
                    const transformedResult = transformResult(value);
                    const chunk = JSON.stringify(transformedResult);
                    const contentLength = (0, calculate_byte_length_1.calculateByteLength)(chunk);
                    const data = [
                        "",
                        "Content-Type: application/json; charset=utf-8",
                        "Content-Length: " + contentLength.toString(),
                        "",
                        chunk,
                    ];
                    if (value.hasNext) {
                        data.push("---");
                    }
                    controller.enqueue(data.join("\r\n"));
                }
            }
            catch (e) {
                controller.error(e);
            }
        },
    });
    return new cross_undici_fetch_1.Response(readableStream, responseInit);
}
exports.getMultipartResponse = getMultipartResponse;
function getPushResponse(asyncExecutionResult, transformResult = exports.DEFAULT_TRANSFORM_RESULT_FN) {
    const headersInit = {
        "Content-Type": "text/event-stream",
        Connection: "keep-alive",
        "Cache-Control": "no-cache",
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    const readableStream = new cross_undici_fetch_1.ReadableStream({
        async start(controller) {
            try {
                const iterator = asyncExecutionResult[Symbol.asyncIterator]();
                while (true) {
                    const { done, value } = await iterator.next();
                    if (done) {
                        controller.close();
                        break;
                    }
                    const transformedResult = transformResult(value);
                    const chunk = JSON.stringify(transformedResult);
                    controller.enqueue(`data: ${chunk}\n\n`);
                }
            }
            catch (e) {
                controller.error(e);
            }
        },
    });
    return new cross_undici_fetch_1.Response(readableStream, responseInit);
}
exports.getPushResponse = getPushResponse;
async function* getSingleResult(payload) {
    yield payload;
}
function getErrorResponse({ message, status = 500, headers = {}, errors = [{ message }], transformResult = exports.DEFAULT_TRANSFORM_RESULT_FN, isEventStream, }) {
    const payload = {
        errors,
    };
    if (isEventStream) {
        return getPushResponse(getSingleResult(payload), transformResult);
    }
    return new cross_undici_fetch_1.Response(JSON.stringify(transformResult(payload)), {
        status,
        headers,
    });
}
exports.getErrorResponse = getErrorResponse;
