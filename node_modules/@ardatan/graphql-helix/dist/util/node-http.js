"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendNodeResponse = exports.getNodeRequest = void 0;
const is_async_iterable_1 = require("./is-async-iterable");
const cross_undici_fetch_1 = require("cross-undici-fetch");
async function getNodeRequest(nodeRequest) {
    const fullUrl = `${nodeRequest.protocol || "http"}://${nodeRequest.hostname || nodeRequest.headers.host || "localhost"}${nodeRequest.url || '/graphql'}`;
    const maybeParsedBody = nodeRequest.body;
    const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;
    if (nodeRequest.method !== "POST") {
        return new cross_undici_fetch_1.Request(fullUrl, {
            headers: nodeRequest.headers,
            method: nodeRequest.method,
        });
    }
    else if (maybeParsedBody) {
        const request = new cross_undici_fetch_1.Request(fullUrl, {
            headers: nodeRequest.headers,
            method: nodeRequest.method,
        });
        Object.defineProperties(request, {
            json: {
                value: async () => nodeRequest.body,
            },
            text: {
                value: async () => JSON.stringify(nodeRequest.body),
            },
            body: {
                get: () => new cross_undici_fetch_1.Request(fullUrl, {
                    method: 'POST',
                    body: JSON.stringify(nodeRequest.body),
                }).body,
            }
        });
        return request;
    }
    else if ((0, is_async_iterable_1.isAsyncIterable)(rawRequest)) {
        const body = new cross_undici_fetch_1.ReadableStream({
            async start(controller) {
                try {
                    for await (const chunk of rawRequest) {
                        controller.enqueue(chunk);
                    }
                    controller.close();
                }
                catch (e) {
                    controller.error(e);
                }
            },
        });
        return new cross_undici_fetch_1.Request(fullUrl, {
            headers: nodeRequest.headers,
            method: nodeRequest.method,
            body,
        });
    }
    throw new Error(`Unknown request`);
}
exports.getNodeRequest = getNodeRequest;
async function sendNodeResponse(responseResult, nodeResponse) {
    const headersObj = {};
    responseResult.headers.forEach((value, name) => {
        headersObj[name] = headersObj[name] || [];
        headersObj[name].push(value);
    });
    nodeResponse.writeHead(responseResult.status, headersObj);
    const responseBody = await responseResult.body;
    if (responseBody == null) {
        throw new Error("Response body is not supported");
    }
    if (responseBody instanceof Uint8Array) {
        nodeResponse.write(responseBody);
        nodeResponse.end();
    }
    else if ((0, is_async_iterable_1.isAsyncIterable)(responseBody)) {
        for await (const chunk of responseBody) {
            if (chunk) {
                nodeResponse.write(chunk);
            }
        }
        nodeResponse.end();
    }
    else if ("getReader" in responseBody) {
        const reader = responseBody.getReader();
        while (true) {
            const { done, value } = await reader.read();
            if (value) {
                nodeResponse.write(value);
            }
            if (done) {
                nodeResponse.end();
                break;
            }
        }
        nodeResponse.on("close", () => {
            reader.releaseLock();
        });
    }
    else {
        throw new Error(`Unrecognized Response type provided`);
    }
}
exports.sendNodeResponse = sendNodeResponse;
