import { calculateByteLength } from './calculate-byte-length.mjs';
import { ReadableStream, Response } from "cross-undici-fetch";
export const DEFAULT_TRANSFORM_RESULT_FN = (result) => result;
export function getRegularResponse(executionResult, transformResult = DEFAULT_TRANSFORM_RESULT_FN) {
    const transformedResult = transformResult(executionResult);
    const responseBody = JSON.stringify(transformedResult);
    const contentLength = calculateByteLength(responseBody);
    const headersInit = {
        "Content-Type": 'application/json',
        "Content-Length": contentLength.toString()
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    return new Response(responseBody, responseInit);
}
export function getMultipartResponse(asyncExecutionResult, transformResult = DEFAULT_TRANSFORM_RESULT_FN) {
    const headersInit = {
        Connection: "keep-alive",
        "Content-Type": 'multipart/mixed; boundary="-"',
        "Transfer-Encoding": "chunked",
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    const readableStream = new ReadableStream({
        async start(controller) {
            try {
                controller.enqueue(`---`);
                const iterator = asyncExecutionResult[Symbol.asyncIterator]();
                while (true) {
                    const { done, value } = await iterator.next();
                    if (done) {
                        controller.enqueue("\r\n-----\r\n");
                        controller.close();
                        break;
                    }
                    const transformedResult = transformResult(value);
                    const chunk = JSON.stringify(transformedResult);
                    const contentLength = calculateByteLength(chunk);
                    const data = [
                        "",
                        "Content-Type: application/json; charset=utf-8",
                        "Content-Length: " + contentLength.toString(),
                        "",
                        chunk,
                    ];
                    if (value.hasNext) {
                        data.push("---");
                    }
                    controller.enqueue(data.join("\r\n"));
                }
            }
            catch (e) {
                controller.error(e);
            }
        },
    });
    return new Response(readableStream, responseInit);
}
export function getPushResponse(asyncExecutionResult, transformResult = DEFAULT_TRANSFORM_RESULT_FN) {
    const headersInit = {
        "Content-Type": "text/event-stream",
        Connection: "keep-alive",
        "Cache-Control": "no-cache",
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    const readableStream = new ReadableStream({
        async start(controller) {
            try {
                const iterator = asyncExecutionResult[Symbol.asyncIterator]();
                while (true) {
                    const { done, value } = await iterator.next();
                    if (done) {
                        controller.close();
                        break;
                    }
                    const transformedResult = transformResult(value);
                    const chunk = JSON.stringify(transformedResult);
                    controller.enqueue(`data: ${chunk}\n\n`);
                }
            }
            catch (e) {
                controller.error(e);
            }
        },
    });
    return new Response(readableStream, responseInit);
}
async function* getSingleResult(payload) {
    yield payload;
}
export function getErrorResponse({ message, status = 500, headers = {}, errors = [{ message }], transformResult = DEFAULT_TRANSFORM_RESULT_FN, isEventStream, }) {
    const payload = {
        errors,
    };
    if (isEventStream) {
        return getPushResponse(getSingleResult(payload), transformResult);
    }
    return new Response(JSON.stringify(transformResult(payload)), {
        status,
        headers,
    });
}
