import { handleRequest } from '@graphql-yoga/handler';
import { GraphQLScalarType } from 'graphql';
import { envelop, useSchema, useExtendContext, enableIf, useLogger, useMaskedErrors } from '@envelop/core';
import { useDisableIntrospection } from '@envelop/disable-introspection';
import { useValidationCache } from '@envelop/validation-cache';
import { useParserCache } from '@envelop/parser-cache';
import { dummyLogger } from 'ts-log';
import { makeExecutableSchema } from '@graphql-tools/schema';

const DEFAULT_CORS_OPTIONS = {
    origin: ['*'],
    methods: ['GET', 'HEAD', 'PUT', 'PATCH', 'POST', 'DELETE'],
    optionsSuccessStatus: 204,
};
/**
 * Base class that can be extended to create a GraphQL server with any HTTP server framework.
 */
class BaseGraphQLServer {
    constructor(options) {
        var _a;
        /**
         * Request handler for helix
         */
        this.handleRequest = handleRequest;
        this.schema =
            'schema' in options
                ? options.schema
                : makeExecutableSchema({
                    typeDefs: [options.typeDefs, 'scalar File', 'scalar Blob'],
                    resolvers: {
                        File: GraphQLFile,
                        Blob: GraphQLBlob,
                        ...options.resolvers,
                    },
                });
        this.logger = dummyLogger;
        this.isDev = (_a = options.isDev) !== null && _a !== void 0 ? _a : false;
        this.getEnveloped = envelop({
            plugins: [
                // Use the schema provided by the user
                useSchema(this.schema),
                // Performance things
                useParserCache(),
                useValidationCache(),
                // Inject logger instance to context. Useful to use logger in resolvers.
                useExtendContext(() => ({ logger: this.logger })),
                // Log events - useful for debugging purposes
                enableIf(this.isDev, useLogger({
                    logFn: (eventName, events) => {
                        var _a, _b, _c, _d, _e;
                        if (eventName === 'execute-start') {
                            const context = events.args.contextValue;
                            const query = (_b = (_a = context.request) === null || _a === void 0 ? void 0 : _a.body) === null || _b === void 0 ? void 0 : _b.query;
                            const variables = (_d = (_c = context.request) === null || _c === void 0 ? void 0 : _c.body) === null || _d === void 0 ? void 0 : _d.variables;
                            const headers = (_e = context.request) === null || _e === void 0 ? void 0 : _e.headers;
                            this.logger.debug(eventName);
                            this.logger.debug(query, 'query');
                            // there can be no variables
                            if (variables && Object.keys(variables).length > 0) {
                                this.logger.debug(variables, 'variables');
                            }
                            this.logger.debug(headers, 'headers');
                        }
                        if (eventName === 'execute-end') {
                            this.logger.debug(eventName);
                            this.logger.debug(events.result, 'response');
                        }
                    },
                })),
                // Disable introspection in production
                enableIf(!this.isDev, useDisableIntrospection()),
                // Mask errors in production
                enableIf(!this.isDev, useMaskedErrors()),
                ...(options.context != null
                    ? [
                        useExtendContext(typeof options.context === 'function'
                            ? options.context
                            : () => options.context),
                    ]
                    : []),
                ...(options.plugins || []),
            ],
        });
        if (options.cors != null) {
            if (typeof options.cors === 'function') {
                const userProvidedCorsOptionsFactory = options.cors;
                this.corsOptionsFactory = (...args) => {
                    const corsOptions = userProvidedCorsOptionsFactory(...args);
                    return {
                        ...DEFAULT_CORS_OPTIONS,
                        ...corsOptions,
                    };
                };
            }
            else if (typeof options.cors === 'object') {
                const corsOptions = {
                    ...DEFAULT_CORS_OPTIONS,
                    ...options.cors,
                };
                this.corsOptionsFactory = () => corsOptions;
            }
            else if (typeof options.cors === 'boolean') {
                this.corsOptionsFactory = () => DEFAULT_CORS_OPTIONS;
            }
        }
    }
}
const GraphQLBlob = new GraphQLScalarType({
    name: 'Blob',
    serialize: (value) => value,
    parseValue: (value) => value,
    extensions: {
        codegenScalarType: 'Blob',
    },
});
const GraphQLFile = new GraphQLScalarType({
    name: 'File',
    serialize: (value) => value,
    parseValue: (value) => value,
    extensions: {
        codegenScalarType: 'File',
    },
});

export { BaseGraphQLServer, GraphQLBlob, GraphQLFile };
